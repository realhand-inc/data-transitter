#!/usr/bin/python3
"""
follow_direct_xr - Real-time gimbal follower via direct XR headset tracking
Reads headset orientation via XrClient and controls the DJI RS2/RS3 gimbal to follow.
Eliminates network latency by using direct data acquisition instead of ZMQ.
"""

import time
import os
import sys
import numpy as np

# Setup paths
file_dir = os.path.dirname(__file__)
sys.path.append(file_dir)

# Add project root to path for xrobotoolkit_teleop
script_dir = os.path.dirname(__file__)
project_root = os.path.abspath(os.path.join(script_dir, os.pardir, os.pardir))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from dji_controller import DJIController
from xrobotoolkit_teleop.common.xr_client import XrClient


def quaternion_to_euler(q: np.ndarray) -> np.ndarray:
    """
    Convert a quaternion [qx, qy, qz, qw] to Euler angles [roll, pitch, yaw] in radians.
    """
    x, y, z, w = q
    # roll (x-axis rotation)
    t0 = +2.0 * (w * x + y * z)
    t1 = +1.0 - 2.0 * (x * x + y * y)
    roll_x = np.arctan2(t0, t1)

    # pitch (y-axis rotation)
    t2 = +2.0 * (w * y - z * x)
    t2 = np.clip(t2, -1.0, 1.0)
    pitch_y = np.arcsin(t2)

    # yaw (z-axis rotation)
    t3 = +2.0 * (w * z + x * y)
    t4 = +1.0 - 2.0 * (y * y + z * z)
    yaw_z = np.arctan2(t3, t4)

    return np.array([roll_x, pitch_y, yaw_z])


def map_and_clamp_euler(euler_rad: np.ndarray) -> np.ndarray:
    """
    Map headset Euler angles to gimbal coordinate system with range protection.

    Args:
        euler_rad: numpy array [x1, y1, z1] in radians (roll, pitch, yaw)

    Returns:
        numpy array [x2, y2, z2] in degrees with axis remapping and clamping
    """
    x1, y1, z1 = euler_rad

    # Convert radians to degrees
    rad_to_deg = 180.0 / np.pi

    # Axis remapping: x2=y1 (pitch), y2=z1 (yaw), z2=x1 (roll)
    x2_deg = -y1 * rad_to_deg
    y2_deg = x1 * rad_to_deg
    z2_deg = z1 * rad_to_deg

    # Range clamping for safety
    x2 = np.clip(x2_deg, -180, 180)
    y2 = np.clip(y2_deg, -100, 100)
    z2 = np.clip(z2_deg, -35, 35)

    return np.array([x2, y2, z2])


class PID:
    """PID controller for smooth gimbal motion"""
    def __init__(self, kp, ki, kd, dt):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.dt = dt
        self.previous_error = np.array([0.0, 0.0, 0.0])
        self.integral = np.array([0.0, 0.0, 0.0])

    def update(self, desired_pose, current_pose):
        error = desired_pose - current_pose
        self.integral += error * self.dt
        # Anti-windup: limit integral term
        self.integral = np.clip(self.integral, -50, 50)
        derivative = (error - self.previous_error) / self.dt
        output = self.kp * error + self.ki * self.integral + self.kd * derivative
        self.previous_error = error
        return output

    def reset(self):
        self.previous_error = np.array([0.0, 0.0, 0.0])
        self.integral = np.array([0.0, 0.0, 0.0])


if __name__ == "__main__":
    print("\n" * 3)
    print("=" * 50)
    print("    DJI RS2/RS3 Gimbal Direct XR Follower")
    print("=" * 50)
    print("\n[INFO] Initializing XR headset tracking...")
    print("[INFO] Press CTRL+C to stop\n")

    # Initialize XrClient
    xr_client = None
    try:
        xr_client = XrClient()
        print("[INFO] XrClient initialized successfully")
    except Exception as e:
        print(f"[ERROR] Failed to initialize XrClient: {e}")
        print("[INFO] Please ensure XRoboToolkit PC Service is running and XR device is connected.")
        sys.exit(1)
    
    # Initialize DJI controller
    try:
        controller = DJIController("can0")
        try:
            controller.bus.flush_tx_buffer()
        except NotImplementedError:
            pass
        print("[INFO] DJI Controller initialized successfully")
    except Exception as e:
        print(f"[ERROR] Failed to initialize DJI Controller: {e}")
        print("[INFO] Make sure to run 'sudo can-up' first")
        sys.exit(1)
    
    # PID controller setup
    kp = np.array([2.0, 2.0, 2.0])
    ki = np.array([0.1, 0.1, 0.1])
    kd = np.array([0.5, 0.5, 0.5])
    dt = 0.05  # 50ms control loop
    
    pid_controller = PID(kp, ki, kd, dt)
    
    print("[INFO] Tracking headset orientation...")
    print("-" * 50)

    frame_count = 0
    start_time = time.time()

    try:
        while True:
            # Get headset pose from XrClient
            head_pose = xr_client.get_pose_by_name("headset")

            if head_pose is not None:
                # Convert quaternion to Euler angles
                euler_angles = quaternion_to_euler(head_pose[3:])
                # Apply axis remapping and range clamping
                target_pose = map_and_clamp_euler(euler_angles)
                status = "OK"
            else:
                # If headset data is not available, send zeros
                target_pose = np.array([0.0, 0.0, 0.0])
                status = "NO HEADSET"

            # Get current gimbal position
            current_pose = np.array([
                controller.yaw,
                controller.pitch,
                controller.roll
            ])

            # Send target position directly to gimbal (no PID calculation)
            controller.set_ypr(target_pose, dt * 2)

            # Calculate frequency
            frame_count += 1
            elapsed_time = time.time() - start_time
            frequency = frame_count / elapsed_time if elapsed_time > 0 else 0

            # Print status
            print(f"[{frame_count:6d}] [{status:^12}] Target: {target_pose[0]:>7.2f} {target_pose[1]:>7.2f} {target_pose[2]:>7.2f} | "
                  f"Current: {current_pose[0]:>7.2f} {current_pose[1]:>7.2f} {current_pose[2]:>7.2f} | "
                  f"Freq: {frequency:>6.2f} Hz")

            time.sleep(dt)
            
    except KeyboardInterrupt:
        print("\n" + "-" * 50)
        print("[INFO] Stopping gimbal follower...")
        print("[INFO] Returning gimbal to home position...")

        try:
            controller.bus.flush_tx_buffer()
        except NotImplementedError:
            pass

        # Return to home position
        controller.set_pos(0, 0, 0)
        time.sleep(2)

        print("[INFO] Done. Goodbye!")

    finally:
        # Close XrClient
        if xr_client:
            try:
                xr_client.close()
                print("[INFO] XrClient closed.")
            except Exception as e:
                print(f"[ERROR] Error closing XrClient: {e}")
        os._exit(0)
